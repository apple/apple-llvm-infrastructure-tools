#!/bin/bash

NONGIT_OK=1
. "$(dirname $0)"/helpers/init.sh
helper canonicalize_path
helper mt_llvm_svn
helper mt_llvm_svn2git
helper mt_list_commits

usage() {
    printf "%s\n"                                                             \
        "usage: $(print_cmdname) [options] <name>"                            \
        ""                                                                    \
        "   --config-dir=<dir>"                                               \
        "                   Config directory to find <name>.mt-config in"     \
        "   --git-dir=<dir> Git directory to use (default: $DEFAULT_GIT_DIR)" \
        "   --[no-]verbose  Use verbose output (default: \$VERBOSE)"          \
        "   --[no-]setup    Set up and update remotes (default: on)"          \
        "   --[no-]clean    Clean local progress (default: off, for now)"     \
        "   --[no-]generate Generate branches/tags/etc. (default: on)"        \
        "   --[no-]push     Push to the destination(s) (default: on)"         \
        "   --push-only     Only push previous results"                       \
        "   --dry-run       Don't actually generate anything, just debug"     \
        "                   commands that would run"                          \
        "   --check-for-work"                                                 \
        "                   Print the first piece of work to do, but"         \
        "                   don't actually do anything"                       \
        "   --assume-branch-work"                                             \
        "                   Meant for testing, assume there is work to do on" \
        "                   a branch (don't return early).  Forces a call to" \
        "                   mt-translate-ref."                                \
        "   --sync-destinations"                                              \
        "                   Sync destinations repeatedly until there is no"   \
        "                   work to do, relying on another agent to push it;" \
        "                   implies --check-for-work"                         \
        "   --sync-destinations-retries=<count>"                              \
        "                   Only attempt to sync <count> times"               \
        "   --sync-destinations-delay=<delay>"                                \
        "                   Wait <delay> seconds between attempts"            \
        "   --dump-mt-config"                                                 \
        "                   Dump the mt-config to stdout"                     \
        "   --dump-merged-mt-config"                                          \
        "                   Dump the mt-config merged with its upstream"      \
        "   --show-upstream Show the upstream, if any"                        \
        "   --show-{monorepo,splitref}-destination"                           \
        "                   Show the monorepo or splitref desitnation repo"   \
        "   --list-actions  List generate actions in order (and exit)"        \
        "   --list-merged-actions"                                            \
        "                   List generate actions, including upstream"        \
        "   --list-repos    List repos (and exit)"                            \
        "   --list-branches List branches to generate (and exit)"             \
        "   --list-tags     List tags to generate (and exit)"                 \
        "   --list-merged-(tags|branches)"                                    \
        "                   List along with upstream mt-configs (and exit)"   \
        "   --list-dirs     List declared dirs (and exit)"                    \
        "   --list-(active|inactive|repeat)-dirs=(<branch>|<tag>)"            \
        "                   List active, inactive, or repeated dirs for"      \
        "                   <branch> or <tag> (and exit)"                     \
        "   --list-(active|inactive|repeat|all)-refdirs=(<branch>|<tag>"      \
        "                   List active, inactive, repeated, or all dirs for" \
        "                   <branch> or <tag> in <ref>:<dir> format (and exit)"
}

DEFAULT_CONFIG_DIR="$(
    relative_canonicalize_path "$APPLE_LLVM_LIBEXEC_DIR/../../mt-config")"
DEFAULT_GIT_DIR=mt-repo.git

print_list() {
    local list="$1"
    shift
    local which="$list"
    case "$list" in
        --show-upstream) show_upstream; return $? ;;
        --show-monorepo-destination) show_monorepo_destination; return $? ;;
        --show-splitref-destination) show_splitref_destination; return $? ;;
        *) true ;;
    esac

    which="${which#--list-}"
    which="${which%%=*}"
    which="${which//-/_}"

    is_function print_"$which" || usage_error "unknown option '$list'"
    print_"$which" "$@"
}
print_actions_impl()   { cat "$1" | awk '$1 == "generate" {print $2, $3}'; }
print_actions()        { print_actions_impl "$MT_CONFIG"; }
print_merged_actions() { print_actions_impl "$MERGED_MT_CONFIG"; }
print_repos() { cat "$MERGED_MT_CONFIG" | awk '$1 == "repo" {print $2, $3}'; }
print_refs_impl() {
    print_actions_impl "$2" | awk -v type="$1" '$1==type{print $2}' |
    sort --version-sort
}
print_branches()        { print_refs_impl branch "$MT_CONFIG"; }
print_tags()            { print_refs_impl tag    "$MT_CONFIG"; }
print_merged_branches() { print_refs_impl branch "$MERGED_MT_CONFIG"; }
print_merged_tags()     { print_refs_impl tag    "$MERGED_MT_CONFIG"; }
print_dirs() {
    cat "$MERGED_MT_CONFIG" | awk '$1 == "declare-dir" {print $2}' | sort
}
print_repeat() {
    awk -v branch="$1" '
    $1 == "repeat" && $2 == branch {
        if (x) {
            printf "error: second repeat for branch %s\n", branch >"/dev/stderr"
            broken = 1
            exit 1
        }
        x = $3
    }
    END { if (x && !broken) print x }
    ' "$MERGED_MT_CONFIG"
}
print_start() {
    awk -v branch="$1" '
    $1 == "start" && $2 == branch {
        if (x) {
            printf "error: second start for branch %s\n", branch >"/dev/stderr"
            broken = 1
            exit 1
        }
        x = $3
    }
    END { if (x && !broken) print x }
    ' "$MERGED_MT_CONFIG"
}
print_active_dirs()      { print_dirs_impl "$1" 1 0 0 0 0; }
print_inactive_dirs()    { print_dirs_impl "$1" 0 1 0 0 0; }
print_repeat_dirs()      { print_dirs_impl "$1" 0 0 1 0 0; }
print_active_refdirs()   { print_dirs_impl "$1" 1 0 0 1 0; }
print_inactive_refdirs() { print_dirs_impl "$1" 0 1 0 1 0; }
print_repeat_refdirs()   { print_dirs_impl "$1" 0 0 1 1 0; }
print_all_refdirs()      { print_dirs_impl "$1" 1 1 1 1 0; }
print_undeclared_dirs()  { print_dirs_impl "$1" 1 0 0 0 1; }
print_dirs_impl() {
    local branch="$1" undecl=$6
    awk_helper mt-config-dirs -v branch="$branch" -v active=$2              \
        -v inactive=$3 -v repeat=$4 -v refs=$5 -v undecl=$undecl            \
        "$MERGED_MT_CONFIG" "$MERGED_MT_CONFIG"
}

show_upstream() {
    run cat "$MT_CONFIG" |
    awk '
    $1 == "upstream" {
        if (upstream) {
            printf "error: second upstream declaration not supported\n" >"/dev/stderr"
            printf "note: 1st upstream: %s\n", upstream >"/dev/stderr"
            printf "note: 2nd upstream: %s\n", $2 >"/dev/stderr"
            exit 1
        }
        upstream = $2
    }
    END { if (upstream) print upstream }'
}

show_monorepo_destination() { show_destination monorepo; }
show_splitref_destination() { show_destination splitref; }
show_destination() {
    run cat "$MT_CONFIG" |
    awk -v which="$1" '
    $1 == "destination" && $2 == which {
        if (destination) {
            destination = destination " " $3
            count = count + 1
        } else {
            destination = $3
            count = 1
        }
    }
    END {
      if (count == 0) {
          printf "error: no %s destination specified\n", which >"/dev/stderr"
          exit 1
      }
      if (count > 1) {
          printf "error: multiple %s destinations specified: %s\n", \
            which, destination >"/dev/stderr"
          exit 1
      }
      print destination
    }'
}

validate_mt_config() {
    # Check repos aren't duplicated.
    print_repos | awk '
    names[$1] {
        printf "error: duplicate repo name '\''%s'\''\n", $1 >"/dev/stderr"
        exit 1
    }
    urls[$2] {
        printf "error: duplicate repo url '\''%s'\''\n", $2 >"/dev/stderr"
        exit 1
    }
    { names[$1]=1; urls[$2]=1 }
    ' || return 1

    # Check branches aren't duplicated.
    print_merged_branches | awk '
    branches[$1] {
        printf "error: duplicate branch '\''%s'\''\n", $1 >"/dev/stderr"
        exit 1
    }
    { branches[$1]=1 }
    ' || return 1

    # Check directories aren't duplicated.
    print_dirs | awk '
    dirs[$1] {
        printf "error: re-declared directory '\''%s'\''\n", $1 >"/dev/stderr"
        exit 1
    }
    { dirs[$1]=1 }
    ' || return 1

    # Check that there is at most one mapping and that we don't have an
    # upstream if we have a mapping.
    print_actions | awk -v upstream="$(show_upstream)" '
    $1 != "mapping" { next }
    upstream {
        printf                                                                \
            "error: cannot have upstream '\''%s'\'' and mapping '\''%s'\''\n",\
            upstream, $2 >"/dev/stderr"
        exit 1
    }
    mapping {
        printf "error: too many mappings: '\''%s'\'' and '\''%s'\''\n",       \
            mapping, $2 >"/dev/stderr"
        exit 1
    }
    { mapping=$2 }
    ' || return 1
}
MTDB_REF=refs/mt/mt-db
MTDB_SHA1= MTDB_LOCAL_REF=
mtdb_local_ref() { printf "%s.%s\n" "$MTDB_REF" "$1"; }
mt_setup() {
    GIT_DIR="$(canonicalize_path "$GIT_DIR")"
    MT_CONFIG="$(canonicalize_path "$MT_CONFIG")"
    CONFIG_DIR="$(canonicalize_path "$CONFIG_DIR")"
    MERGED_MT_CONFIG="$(canonicalize_path "$MERGED_MT_CONFIG")"

    # Always change directory.
    if ! should_setup; then
        run cd "$GIT_DIR"
        return $?
    fi

    # Verbose output.
    local gitout hide
    setup_gitout_and_hide

    # Clean up any local progress.
    ! should_clean || clean || exit 1

    log "Setting up and syncing $GIT_DIR"
    log "  (based on $MT_CONFIG)"
    [ -d "$GIT_DIR" ] ||
        run --hide-errors git init -q --bare "$GIT_DIR" >$gitout ||
        error "failed to initialize '$GIT_DIR'"
    run cd "$GIT_DIR" || error "failed to cd to $GIT_DIR"
    log "Updating remotes in parallel"

    # Set up repos in reverse so that upstream repos are fetched last and are
    # more likely to be up-to-date.
    reverse_lines() {
        awk '{row[NR] = $0} END{for(r=NR; r; r = r-1){print row[r]}}'
    }
    print_repos | reverse_lines | {
        local name= url=
        while read name url; do
            mt_setup_repo || return 1
        done
    } || return 1

    # Compute the destination repos.
    local splitdest monodest
    splitdest="$(show_splitref_destination)" || exit 1
    monodest="$(show_monorepo_destination)" || exit 1

    log "Combining object databases"
    print_repos |
    while read name url; do
        log "  - $name"
        # Ignore errors here, since often the remote will already exist.
        run --hide-errors git remote add $name $PWD/clones/$name.git >$gitout

        # Use a special tags namespace unless this is a generated monorepo
        # destination.
        local remotetags tagsopt
        if [ "$name" = "$monodest" ]; then
            # We need --tags in order to fetch *all* tags.
            remotetags="refs/tags/*"
            tagsopt=--tags
        else
            # We still need --no-tags to avoid *also* fetching some tags to
            # refs/tags/*.
            remotetags="refs/tags/remotes/$name/*/remote-tag"
            tagsopt=--no-tags
        fi
        run $hide git fetch -q $name $tagsopt       \
            "+refs/heads/*:refs/remotes/$name/*"    \
            "+refs/tags/*:$remotetags"              \
            >$gitout ||
        error "failed to sync '$GIT_DIR'"
    done || return 1

    # Pack refs for faster rev-parse queries.
    run git pack-refs --all || return 1

    # Check that the destination repos work.
    run git remote | run grep "$splitdest" >/dev/null ||
        error "splitref destination '$splitdest' is not a repo"
    run git remote | run grep "$monodest" >/dev/null ||
        error "monorepo destination '$monodest' is not a repo"

    # Fetch the mt-db ref.
    fetch_destination_mtdb "$monodest" || exit 1
}
fetch_destination_mtdb() {
    local monodest="$1"
    log "Syncing mt-db from $monodest"
    MTDB_SHA1=$(run git ls-remote $monodest $MTDB_REF | awk '{print $1}')
    [ -n "$MTDB_SHA1" ] || return 0
    run git fetch -q --force $monodest $MTDB_REF:$MTDB_LOCAL_REF ||
        error "failed to fetch $MTDB_REF from $monodest"
}

setup_gitout_and_hide() {
    gitout=/dev/null
    hide=--hide-errors
    if [ ! "${VERBOSE:-0}" = 0 ]; then
        gitout=/dev/stderr
        hide=
    fi
}

clean() {
    local existing
    existing="$(git show-ref | grep -e ^refs/mt -e ^refs/heads |
        awk '{print $2}')" ||
        error "failed to look up refs to clean"
    [ -z "$existing" ] || run git update-ref -d $existing ||
        error "failed to clean local refs: $existing"
    local prev_existing=
    while existing="$(git worktree list --porcelain |
        awk '$1=="worktree"{print substr($0,10); exit 0} END{exit 1}')"; do
        # Prevent an infinite loop, if somehow we stop making progress.
        # Probably not actaully reachable, but better to be paranoid.
        [ ! "$prev_existing" = "$existing" ] ||
            error "failed to clean worktrees"
        prev_existing="$existing"

        run git worktree remove --force "$existing" ||
            error "failed to clean worktree: $existing"
    done
}

MERGED_MT_CONFIG=
initialize_merged_mt_config() {
    local upstream
    upstream="$(show_upstream)" || exit 1
    if [ -z "$upstream" ]; then
        MERGED_MT_CONFIG="$MT_CONFIG"
        return 0
    fi

    MERGED_MT_CONFIG="$(mktemp -q)" ||
        error "failed to generate temp file for merged mt-config"
    mt_register_paths_to_clean_up "$MERGED_MT_CONFIG"

    local grepexpr="^upstream "
    run git apple-llvm mt generate --config-dir "$CONFIG_DIR" \
        --dump-merged-mt-config "$upstream" |
    grep -v "$grepexpr" >"$MERGED_MT_CONFIG" ||
        error "could not create merged mt-config from upstream '$upstream'"
    run cat "$MT_CONFIG" | run grep -v "$grepexpr" >>"$MERGED_MT_CONFIG" ||
        error "could not patch merged mt-config for '$NAME'"
}

sync_upstream_destinations() {
    [ -n "$upstream" ] ||
        error "internal: sync_upstream_destinations called without upstream?"

    log "Syncing destination repos for upstream '$upstream'"
    run git apple-llvm mt generate --sync-destinations \
        --sync-destinations-delay=$SYNC_DELAY \
        --sync-destinations-retries=$SYNC_RETRIES \
        --config-dir="$CONFIG_DIR" --git-dir="$GIT_DIR" \
        "$upstream"
    local status=$?
    log "Finished syncing destination repos for upstream '$upstream'"
    [ $status = 0 ] || error "upstream '$upstream' out-of-date"
}
fetch_destinations() {
    print_repos | run awk -v m="$monorepo" -v s="$splitref" \
        '$1 == m || $1 == s { print $0 }' |
    while read name url; do
        mt_setup_repo || exit 1

        # Note: we want to fetch tags as well, in case new ones have been
        # pushed.
        run $hide git fetch -q --tags $name >$gitout ||
            error "failed to sync '$GIT_DIR'"
    done || exit 1

    fetch_destination_mtdb "$monorepo" || exit 1
}
sync_destinations() {
    # Look up destinations.
    local monorepo splitref
    monorepo="$(show_monorepo_destination)" ||
        error "could not extract monorepo destination"
    splitref="$(show_splitref_destination)" ||
        error "could not extract splitref destination"

    # Configure verbose output for mt_setup_repo.
    local gitout hide
    setup_gitout_and_hide

    # Fetch destinations.
    log "Fetching destinations..."
    fetch_destinations

    # Double-check check-for-work is enabled...
    check_for_work || error "--sync-destinations implies --check-for-work?"

    # Check for work, and then repeat as long as there's work to do.
    local actions
    while true; do
        actions="$(generate_actions)" || exit 1
        [ -n "$actions" ] || return 0
        [ $SYNC_RETRIES -gt 0 ] ||
            error "too many retries for --sync-destinations, giving up"
        SYNC_RETRIES=$(( $SYNC_RETRIES - 1 ))
        sleep $SYNC_DELAY

        # Fetch the destinations again.
        log "Fetching destinations again..."
        fetch_destinations || exit 1
    done
}

mt_check_clone() {
    [ -e "$clone" ] || return 1

    # If the clone exists but is not configured correctly, we need to remove it
    # so it can be recreated.  Defer to an impl.
    mt_check_clone_impl "$@" && return 0
    run rm -rf "$clone"
    return 1
}

mt_check_clone_impl() {
    # Must be a git directory configured with a single remote, "origin".
    [ -d "$clone" ] || return 1
    [ . = "$(run $hide git -C "$clone" rev-parse --git-dir)" ] || return 1
    [ origin = "$(run $hide git -C "$clone" remote)" ] || return 1

    # Check and try to fix the URL.
    [ "$url" = "$(run $hide git -C "$clone" remote get-url origin --all)" ] ||
        run $hide git -C "$clone" remote set-url origin "$url" ||
        return 1

    # Remove mirror configuration, since this causes problems for pushes of
    # refspecs with old Git clients.
    local config="$clone"/config
    local key=remote.origin.mirror
    ! run $hide git config --file "$config" $key ||
        run $hide git config --file "$config" --unset $key ||
        return 1

    # Mirror when fetching.
    local fetchspec="+refs/*:refs/*"
    key=remote.origin.fetch
    [ "$fetchspec" = "$(run $hide git config --file "$config" $key)" ] ||
        run $hide git config --file "$config" --replace-all $key "$fetchspec" ||
        return 1

    # No push configuration.
    key=remote.origin.push
    [ -z "$(run $hide git config --file "$config" $key)" ] ||
        run $hide git config --file "$config" --unset-all $key ||
        return 1

    # Looks good.
    return 0
}

mt_make_clone() {
    [ -e "$clone" ] && return 1

    run $hide mkdir -p $(dirname $clone) &&
        run $hide git init -q --bare $clone  &&
        run $hide git -C $clone remote add --mirror=fetch origin $url &&
        return 0

    rm -rf "$clone"
    return 1
}

mt_setup_repo() {
    local clone=clones/$name.git
    log "  - $name"
    mt_check_clone >$gitout || mt_make_clone >$gitout ||
        error "failed to mirror remote '$name'"

    run $hide git -C $clone remote update --prune >$gitout ||
        error "failed to update remote '$name'"
}

report_work() {
    printf "work: generate %s %s\n" "$1" "$2"
    log "found work: generate $*"
    exit 0
}

generate_actions() {
    # Handle implicit action for syncing upstream.
    local upstream
    upstream="$(show_upstream)" || exit 1
    if [ -n "$upstream" ]; then
        log "Syncing mt-db with $upstream"
        sync_upstream_before_generate "$upstream" ||
            error "failed to sync upstream '$upstream'"
    fi

    # Handle explicit actions.
    print_actions |
    while read action object; do
        mt_generate "$action" "$object" ||
            error "failed to generate '$action' using '$object'"
    done
}

has_no_spaces() { [ "${1/ /}" = "$1" ]; }
set_mtdb_symbolic_ref() {
    [ "$(git symbolic-ref "$MTDB_REF" 2>/dev/null)" = "$MTDB_LOCAL_REF" ] ||
        run git symbolic-ref -m "mt generate" "$MTDB_REF" "$MTDB_LOCAL_REF" ||
        error "failed to set up $MTDB_REF"

}
mt_generate() {
    local action="$1"
    local object="$2"
    local generator="mt_generate_$action"
    local fetcher="mt_fetch_$action"
    local pusher="mt_push_$action"

    set_mtdb_symbolic_ref || exit 1
    mt_db_init || error "generate: could not initialize mt-db"

    # Check that we have a generator for this.
    is_function "$generator" ||
        error "generate: unknown action '$action'"

    # Check for a non-empty argument with no spaces.
    [ -n "$object" ] ||
        error "generate: missing action '$action'"
    has_no_spaces "$object" ||
        error "generate: invalid object '$object'"

    if check_for_work; then
        log "Checking for work to generate $action for $object"
    else
        log "Generating $action for $object"
    fi

    # Invoke through wrappers whose logic can be reused.
    local should_push_ref=true
    mt_fetcher   "$fetcher"   "$object" || exit 1
    mt_generator "$generator" "$object" || exit 1
    mt_pusher    "$pusher"    "$object" || exit 1
}
mt_fetcher()   { should_fetch    || return 0; "$@"; }
mt_generator() { should_generate || return 0; "$@"; }
mt_pusher() {
    ! check_for_work || return 0
    should_push || return 0
    "$@"
}

mt_generate_mapping() {
    local remote=$1
    local branches="$(git show-ref | awk '{print $2}' |
    grep ^refs/remotes/$remote)"

    [ -n "$branches" ] || error "no branches found under '$remote'"
    local branch rev
    for branch in $branches; do
        rev=$(mt_llvm_svn $branch) ||
            error "generate mapping: '$branch' has no LLVM revision"
        if (mt_llvm_svn2git "$rev" >/dev/null); then
            log "Mapping for '$branch' up-to-date"
            continue
        fi
        ! check_for_work || report_work mapping "$remote"
        log "Generating mapping for '$branch'"
        run --dry git apple-llvm mt llvm-svn2git-map $branch ||
            error "failed to generate mapping for '$branch'"
    done
}

mt_fetch_mapping() {
    # Nothing to do here, since this is handled by mt_setup.
    true
}

mt_push_mapping() { push_mtdb; }

push_mtdb() {
    local old_mtdb_sha1=$MTDB_SHA1
    MTDB_SHA1=$(run git show-ref $MTDB_REF | awk '{print $1}')
    [ ! "$old_mtdb_sha1" = "$MTDB_SHA1" ] || return 0

    local monodest
    monodest="$(show_monorepo_destination)" || exit 1
    {
        # Push to the local mirror.
        run --dry git push $monodest $MTDB_REF:$MTDB_REF \
            --force-with-lease=$MTDB_REF:$old_mtdb_sha1 &&

        # Push to the remote using --force-with-lease to check for races.
        run --dry git -C clones/$monodest.git push origin $MTDB_REF:$MTDB_REF \
            --force-with-lease=$MTDB_REF:$old_mtdb_sha1
    } || error "failed to push $MTDB_REF to $monodest"
}

sync_upstream_before_generate() {
    [ -n "$upstream" ] ||
        error "internal: sync_upstream_before_generate called without upstream?"

    # Do some things with upstream.  This can set MTDB_REF to upstream.
    mt_fetcher fetch_upstream || exit 1
    local upstream_monorepo
    upstream_monorepo="$(run git apple-llvm mt generate \
        --show-monorepo-destination \
        --config-dir="$CONFIG_DIR" --git-dir="$GIT_DIR" \
        "$upstream")" ||
        error "failed to lookup monorepo destination for '$upstream'"

    # Reset MTDB_REF to downstream and get ready to work.
    set_mtdb_symbolic_ref || exit 1
    mt_db_init || error "generate: could not initialize svn2git"

    # Find the upstream ref.
    local mtdb_upstream_ref="$(mtdb_local_ref "$upstream")"
    run git fetch -q -f "$upstream_monorepo" $MTDB_REF:$mtdb_upstream_ref ||
        error "failed to fetch $mtdb_upstream_ref"

    if check_for_work; then
        log "Checking for work in upstream mt-db: $upstream"
        mt_db_check_upstream "$upstream" || report_work upstream "$upstream"
    else
        log "Merging upstream mt-db: $upstream"
        mt_db_merge_upstream "$upstream" ||
            error "failed to merge upstream '$upstream'"
        mt_db_save || exit 1
        mt_pusher push_mtdb || exit 1
    fi
}

fetch_upstream() {
    # Sync upstream destinations.
    [ -n "$upstream" ] ||
        error "internal: fetch_upstream called without upstream?"
    sync_upstream_destinations || exit 1
}

mt_ref_init_helper() {
    # From parent: local rawtarget
    # From parent: local refsprefix
    # From parent: local target
    # From parent: local mttype
    # From parent: local mtname
    # From parent: local mtprefix
    case "$mttype" in
        branch) refsprefix=refs/heads/ mtprefix=refs/heads/mt/     ;;
        tag)    refsprefix=refs/tags/  mtprefix=refs/heads/mt-tag/ ;;
        *) error "unsupported ref type to generate: '$mttype'"
    esac
    mtname="${rawtarget#$refsprefix}"
    [ ! "${mtname:0:5}" = refs/ ] ||
        error "unrecognized $1 scheme $rawtarget;" \
              "expected <name> or $refsprefix<name>"
    target=$refsprefix$mtname
}

mt_generate_branch() { mt_generate_ref "$@"; }
mt_generate_tag()    { mt_generate_ref "$@"; }
mt_fetch_branch()    { mt_fetch_ref "$@"; }
mt_fetch_tag()       { mt_fetch_ref "$@"; }
mt_push_branch()     { mt_push_ref "$@"; }
mt_push_tag()        { mt_push_ref "$@"; }

mt_generate_ref() {
    # From parent: local action
    # From parent: local should_push_ref
    local mtname refsprefix mtprefix target rawtarget="$1" mttype="$action"
    mt_ref_init_helper

    # Assume we don't have to push.
    should_push_ref=false

    # Check if the ref exists already.
    local work
    run --hide-errors git rev-parse --verify $target >/dev/null || work=1

    # If the ref doesn't exist then there's work to do.  Return early.
    if check_for_work && [ -n "$work" ]; then
        report_work $mttype "$mtname"
        # Not reachable.
    fi

    # For tags, return early if it already exists.
    [ -n "$work" -o ! $mttype = tag ] || return 0

    local refdirs repeat rawstart
    refdirs="$(print_active_refdirs "$rawtarget")" ||
        error "failed to extract active refdirs for $rawtarget"
    repeat="$(print_repeat "$rawtarget")" ||
        error "failed to extract any repeat directive for $rawtarget"
    rawstart="$(print_start "$rawtarget")" ||
        error "failed to extract any start directive for $rawtarget"

    [ -n "$refdirs" ] ||
        error "generate $target: no 'dir' declarations"

    local refdir ref dir dirs sha1
    local mtref mtsha1
    local -a goal_sha1s
    for refdir in $refdirs; do
        ref=${refdir%:*}
        dir=${refdir#*:}
        dirs="${dirs}${dirs:+ }$dir"
        [ "$refdir" = "$ref:$dir" ] ||
            error "generate $target: invalid 'dir' with colon '$refdir'"
        sha1=$(run --dry git rev-parse --verify $ref^{commit}) ||
            error "generate $target: invalid ref '$ref' in dir '$dir'"
        goal_sha1s=( "${goal_sha1s[@]}" "$sha1" )
        [ "$dir" = "*" ] &&
            error "generate $target: invalid dir '$dir' for ref '$ref'"

        # Figure out if there's work to do, if we haven't found it already.
        [ -z "$work" ] || continue
        # Caller: local mtsha1 work
        mtref="mt/$mtname/$dir/mt-split"
        mtsha1=$(run --hide-errors git rev-parse --verify $mtref^{commit})
        [ "$mtsha1" = "$sha1" ] || work=1
        mtsha1="${mtsha1:-$ZERO_SHA1}"
        [ -n "$work" ] || continue
        check_for_work || continue

        # If we found work just report it.
        report_work $mttype "$mtname: $dir"
        # Not reachable...
    done

    refdirs="$(print_all_refdirs "$rawtarget")" ||
        error "failed to extract complete refdirs for $rawtarget"

    # Validate the start ref, regardless of whether we need it, and then
    # canonicalize it.
    [ -z "$rawstart" ] ||
        run --dry git rev-parse --verify $rawstart^{commit} >/dev/null ||
        error "invalid start ref '$rawstart'"
    local start="$(run --dry git rev-parse --symbolic-full-name $rawstart)"
    [ -n "$start" ] || start="$rawstart"

    # Use a loop so we can avoid nesting with "break".
    local handle_repeat_once=
    [ -z "$repeat" ] || handle_repeat_once=1
    while [ -z "$work" -a -n "$handle_repeat_once" ]; do
        handle_repeat_once=

        # Don't bother checking for repeat work if we already know we have to
        # do something.
        [ -z "$work" ] || break

        # Figure out the latest commit date coming in, if the repeat is
        # "no-pass".  This command takes goal_sha1s implicitly and returns via
        # repeat_sha1.
        local repeat_sha1
        run mt_list_first_repeat_sha1 "$repeat"

        mtref="mt/$mtname/mt-repeat"
        mtsha1=$(run --hide-errors git rev-parse --verify $mtref^{commit})
        [ ! "$mtsha1" = "$repeat_sha1" ] || break

        # Check for changes to relevant paths.
        local changed
        changed="$(run mt_list_modified_top_level_paths \
            "$mtsha1" "$repeat_sha1" \
            "$(print_repeat_dirs "$rawtarget")" "$(print_dirs)")"
        [ -n "$changed" ] || break

        # There's work to do.
        work=1
        check_for_work || break
        report_work $mttype "$mtname: $changed"
        # Not reachable...
    done

    # Return early unless there's work to do, or unless tests have asked to
    # bypass this early return.
    assume_branch_work || [ -n "$work" ] || return 0

    refdirs="$(print_all_refdirs "$rawtarget")" ||
        error "failed to extract complete refdirs for $rawtarget"

    should_push_ref=true
    run --dry git apple-llvm mt translate-ref $target "$start" $refdirs ||
        error "failed to generate $mttype '$target'"
}

mt_fetch_ref() {
    # From parent: local action
    local mtname refsprefix mtprefix target rawtarget="$1" mttype="$action"
    mt_ref_init_helper

    # Fetch from local mirror.
    if [ ! $mttype = tag ]; then
        local monodest repeat
        repeat="$(print_repeat "$rawtarget")" ||
            error "failed to extract any repeat directive for $rawtarget"

        monodest="$(show_monorepo_destination)" || exit 1
        mt_fetch_one_branch "$monodest" "$target"
        mt_fetch_one_branch "$monodest" "$mtprefix$mtname/mt-repeat"
    fi

    mt_fetch_splitrefs "$rawtarget"
}

mt_fetch_splitrefs() {
    # Maybe from parent: local mttype
    local mtname refsprefix mtprefix target rawtarget="$1"
    [ -n "$mttype" ] || local mttype=branch
    mt_ref_init_helper

    local splitdest refdirs
    refdirs="$(print_active_refdirs "$rawtarget")" ||
        error "failed to extract active refdirs for $rawtarget"
    splitdest="$(show_splitref_destination)" || exit 1
    for refdir in $refdirs; do
        d=${refdir#*:}
        mt_fetch_one_branch "$splitdest" "$mtprefix$mtname/$d/mt-split"
    done
}

mt_fetch_one_branch() {
    local remote="$1"
    local ref="$2"

    local remote_ref="refs/remotes/$remote/${ref#refs/heads/}^{commit}"
    local sha1
    sha1="$(run --hide-errors git rev-parse --verify "$remote_ref")" ||
        return 0
    run --dry git update-ref "$ref" "$sha1" ||
        error "failed to sync '$ref' from '$remote'"
}

mt_push_ref() {
    # From parent: local mttype
    # From parent: local should_push_ref
    local mtname refsprefix mtprefix target rawtarget="$1" mttype="$action"
    mt_ref_init_helper

    # Return early if there was no work.
    $should_push_ref || return 0

    local branch="$1"
    local old_mtdb_sha1=$MTDB_SHA1
    MTDB_SHA1=$(run git show-ref $MTDB_REF | awk '{print $1}')

    # Push the primary refs.  Need to push to the local mirror, and then from
    # there to the actual remote.
    local monodest repeat
    monodest="$(show_monorepo_destination)" || exit 1
    repeat="$(print_repeat "$rawtarget")" ||
        error "failed to extract any repeat directive for $rawtarget"
    local repeatref
    if [ -n "$repeat" -a ! $mttype = tag ]; then
        repeatref=$mtprefix$mtname/mt-repeat
        run --hide-errors git rev-parse --verify $repeatref^{commit} ||
            repeatref=
    fi
    run --dry git push $monodest $MTDB_REF:$MTDB_REF $target $repeatref \
        --force-with-lease=$MTDB_REF:$old_mtdb_sha1 ||
        error "failed to push $MTDB_REF to local $monodest"
    run --dry git -C clones/$monodest.git push --atomic origin \
        $MTDB_REF:$MTDB_REF $target $repeatref                 \
        --force-with-lease=$MTDB_REF:$old_mtdb_sha1 ||
        error "failed to push $rawtarget and $MTDB_REF to $monodest"

    mt_push_splitrefs "$rawtarget"
}

mt_push_splitrefs() {
    # Maybe from parent: local mttype
    local mtname refsprefix mtprefix target rawtarget="$1"
    [ -n "$mttype" ] || local mttype=branch
    mt_ref_init_helper

    # Push the mt-split refs, which are only needed to optimize the next call.
    local splitdest refdir d ref refs refspec refspecs
    splitdest="$(show_splitref_destination)" || exit 1
    for refdir in $(print_active_refdirs "$rawtarget"); do
        d=${refdir#*:}
        ref="$mtprefix$mtname/$d/mt-split"
        run --hide-errors git rev-parse "$ref"^{commit} >/dev/null ||
            continue
        refs="$refs${refs:+ }$refs"
        refspec="$ref:$ref"
        refspecs="$refspecs${refspecs:+ }$refspec"
    done
    [ -n "$refspecs" ] || return 0
    run --dry git push $splitdest $refspecs ||
        error "failed to push $refs to local $splitdest"
    run --dry git -C clones/$splitdest.git push --atomic origin $refspecs ||
        error "failed to push $refs to $splitdest"
}

mt_generate_splitrefs() {
    # Get the branch name and prepend refs/heads/.
    local heads=refs/heads/
    local rawtarget=$1
    local branch=$rawtarget
    [ "${branch:0:${#heads}}" = $heads ] || branch=$heads$branch

    local refdirs="$(print_active_refdirs "$rawtarget")"
    local repeat="$(print_repeat "$rawtarget")"

    [ -n "$refdirs" ] ||
        error "generate $branch: no 'dir' declarations"
    [ -z "$repeat" ] || error "generate: splitrefs does not support repeat"

    local refdir ref dir
    for refdir in $refdirs; do
        ref=${refdir%:*}
        dir=${refdir#*:}
        [ "$refdir" = "$ref:$dir" ] ||
            error "generate $branch: invalid 'dir' with colon '$refdir'"
        run git rev-parse $ref^{commit} >/dev/null ||
            error "generate $branch: invalid ref '$ref' in dir '$dir'"
        [ "$dir" = "*" ] &&
            error "generate $branch: invalid dir '$dir' for ref '$ref'"
    done

    if check_for_work; then
        local work
        work="$(run git apple-llvm mt update-splitrefs --check-for-work \
            $branch $refdirs)" ||
            error "failed to check for work on branch '$branch'"
        [ -n "$work" ] && report_work splitrefs "$branch"
        return 0
    fi

    run --dry git apple-llvm mt update-splitrefs $branch $refdirs ||
        error "failed to update splitrefs for '$branch'"
}

CONFIG_DIR="$DEFAULT_CONFIG_DIR"
GIT_DIR=$DEFAULT_GIT_DIR

# FIXME: consider setting CLEAN=1 by default.
SETUP=1 CLEAN=0 FETCH=1 GENERATE=1 PUSH=1 PUSH_ONLY=0 CHECK_FOR_WORK=0
DUMP= SYNC=0 SYNC_RETRIES=30 SYNC_DELAY=60 ONLY_VALIDATE=0
should_setup() { [ ! "${SETUP:-0}" = 0 ]; }
should_clean() { [ ! "${CLEAN:-0}" = 0 ]; }
should_fetch() { [ ! "${FETCH:-0}" = 0 ]; }
should_generate() { [ ! "${GENERATE:-0}" = 0 ]; }
should_push() { [ ! "${PUSH:-0}" = 0 ]; }
push_only() { [ ! "${PUSH_ONLY:-0}" = 0 ]; }
only_validate() { [ ! "${ONLY_VALIDATE:-0}" = 0 ]; }
check_for_work() { [ ! "${CHECK_FOR_WORK:-0}" = 0 ]; }
assume_branch_work() { [ ! "${ASSUME_BRANCH_WORK:-0}" = 0 ]; }
should_sync_destinations() { [ ! "${SYNC:-0}" = 0 ]; }
NAME=
while [ $# -gt 0 ]; do
    case "$1" in
        --config-dir|--config-dir=*)
            parse_cmdline_option --config-dir CONFIG_DIR "$@"
            shift $?
            [ -n "$CONFIG_DIR" ] || usage_error "--config-dir cannot be empty"
            [ -d "$CONFIG_DIR" ] ||
                usage_error "expected config dir '$CONFIG_DIR' to be directory"
            ;;
        --git-dir|--git-dir=*)
            parse_cmdline_option --git-dir GIT_DIR "$@"
            shift $?
            [ -n "$GIT_DIR" ] || usage_error "--git-dir cannot be empty"
            ;;
        --verbose|-v) export VERBOSE=1; shift ;;
        --no-verbose) export VERBOSE=0; shift ;;
        --dry-run)  DRY_RUN=1; shift ;;
        --setup)    SETUP=1; shift ;;
        --no-setup) SETUP=0; shift ;;
        --validate-mt-config) ONLY_VALIDATE=1; shift ;;
        --push)     PUSH=1; shift ;;
        --no-push)  PUSH=0; shift ;;
        --clean)    CLEAN=1; shift ;;
        --no-clean) CLEAN=0; shift ;;
        --push-only)PUSH_ONLY=1 GENERATE=0 FETCH=0; shift ;;
        --generate)     GENERATE=1; shift ;;
        --no-generate)  GENERATE=0; shift ;;
        --check-for-work) CHECK_FOR_WORK=1; shift ;;
        --assume-branch-work) ASSUME_BRANCH_WORK=1; shift ;;
        --dump-merged-mt-config) DUMP=merged; shift ;;
        --dump-mt-config)        DUMP=raw;    shift ;;
        --sync-destinations) SYNC=1; CHECK_FOR_WORK=1; shift ;;
        --sync-destinations-retries|--sync-destinations-retries=*)
            parse_cmdline_option --sync-destinations-retries SYNC_RETRIES "$@"
            shift $?
            [ "$SYNC_RETRIES" -ge 0 ] 2>/dev/null ||
                usage_error "invalid argument for --sync-destinations-retries"
            ;;
        --sync-destinations-delay|--sync-destinations-delay=*)
            parse_cmdline_option --sync-destinations-delay SYNC_DELAY "$@"
            shift $?
            [ "$SYNC_DELAY" -ge 0 ] 2>/dev/null ||
                usage_error "invalid argument for --sync-destinations-delay"
            ;;
        --list-*-*dirs|--list-*-*dirs=*)
            LIST="$1"
            parse_cmdline_option "--list-*-*dirs" LIST_BRANCH "$@"
            shift $?
            [ -n "$LIST_BRANCH" ] ||
                usage_error "${LIST%=} requires an argument"
            ;;
        --list-repeat|--list-repeat=*)
            LIST="$1"
            parse_cmdline_option "--list-repeat" LIST_BRANCH "$@"
            shift $?
            [ -n "$LIST_BRANCH" ] ||
                usage_error "${LIST%=} requires an argument"
            ;;
        --list-start|--list-start=*)
            LIST="$1"
            parse_cmdline_option "--list-start" LIST_BRANCH "$@"
            shift $?
            [ -n "$LIST_BRANCH" ] ||
                usage_error "${LIST%=} requires an argument"
            ;;
        --list-*=*) usage_error "unknown option '$1'" ;;
        --list-*|--show-*) LIST="$1"; shift ;;
        --help|--usage|-h) usage; exit 0 ;;
        -*) usage_error "unknown option '$1'" ;;
        *)
            [ -z "$NAME" ] || usage_error "too many positional arguments"
            [ -n "$1" ] || usage_error "empty name for downstream"
            has_no_spaces "$1" || usage_error "branch name '$1' has spaces"
            NAME=$1
            MT_CONFIG="$CONFIG_DIR/$NAME.mt-config"
            [ -r "$MT_CONFIG" ] ||
                usage_error "cannot read '$MT_CONFIG'"
            MTDB_LOCAL_REF="$(mtdb_local_ref $NAME)"
            shift
            ;;
    esac
done

if push_only && should_clean; then
    usage_error "refusing to --clean when invoked with --push-only"
fi

if push_only && check_for_work; then
    usage_error "--push-only doesn't make sense with --check-for-work"
fi

# Nothing to push if we're just checking for work.
check_for_work && PUSH=0

[ -n "$MT_CONFIG" ] || usage_error "missing name of mt-config"

if [ "$DUMP" = raw ]; then
    cat "$MT_CONFIG" || error "could not read $MT_CONFIG"
    exit 0
fi
initialize_merged_mt_config || exit 1

validate_mt_config || exit 1
! only_validate || exit 0

if [ "$DUMP" = merged ]; then
    cat "$MERGED_MT_CONFIG"
    exit 0
elif [ -n "$DUMP" ]; then
    error "internal: invalid '\$DUMP' value '$DUMP'"
fi

if [ -n "$LIST" ]; then
    print_list "$LIST" "$LIST_BRANCH"
    exit $?
fi

if should_sync_destinations; then
    sync_destinations
    exit $?
fi

mt_setup || exit 1
generate_actions || exit 1
exit $?
