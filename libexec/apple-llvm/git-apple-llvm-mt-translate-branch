#!/bin/bash

. "$(dirname "$0")"/helpers/init.sh
helper mt_split2mono
helper mt_llvm_svn2git
helper mt_list_commits

usage() {
    printf "%s\n" \
        "usage: $(print_cmdname) [options] <branch> <ref>:<dir>..."         \
        ""                                                                  \
        "   <branch>      the branch to interleave"                         \
        "   <ref>         a ref to interleave commits from"                 \
        "                   '%<ref>[{no-pass}]' to repeat commits"          \
        "                     from <upstream> (optionally, without passing" \
        "                     other refs)"                                  \
        "                   '-' if there is no relevant split repo"         \
        "   <dir>         the name of the top-level tree to put <ref> into" \
        "                   '-' for root (splat contents)"
}

main() {
    local branch
    local -a refdirs
    parse_cmdline "$@" || return 1

    # Only initialize split2mono db if we will interleave commits.
    # Initializing the blob is not free and there's no point.
    mt_split2mono_init || return 1
    translate_branch "$@" || return 1
    mt_split2mono_save || return 1
}

parse_cmdline() {
    [ $# -ge 1 ] || usage_error "missing <branch>"
    [ $# -ge 2 ] || usage_error "missing <ref>:<dir>..."
    local pos=0
    while [ $# -gt 0 ]; do
        case "$1" in
            --help)
                usage
                exit 0
                ;;
            *:*)
                [ $pos -ne 0 ] || usage_error "invalid branch name '$1'"
                refdirs=( "${refdirs[@]}" "$1" )
                shift
                ;;
            -*)
                usage_error "unknown option '$1'"
                ;;
            *)
                [ $pos -eq 0 ] || usage_error "unexpected argument '$1'"
                branch="$1"
                pos=1
                shift
                ;;
        esac
    done
    [ -n "$branch" ] || usage_error "missing <branch>"
    branch="${branch#refs/heads/}"

    [ ${#refdirs[@]} -gt 0 ] || usage_error "missing <ref>:<dir>"
}

translate_branch() {
    local current
    current=$(run --hide-errors git rev-parse --verify \
        refs/heads/$branch^{commit}) ||
        current=$ZERO_SHA1

    local r d rd ref sha1 goal_sha1
    local -a listdirs # refs to list commits of and for which directory
    local -a repeated # directories getting repeated
    local repeated_root # the root is getting repeated
    local -a sha1dirs # command-line for split2mono interleave-commits
    local -a goal_sha1dirs # goal sha1 for each active directory
    local repeat suffix
    local nopass
    local declared # all declared directories, except '-'
    for rd in "${refdirs[@]}"; do
        r="${rd%:*}"
        d="${rd##*:}"
        suffix="$d/mt-split"

        # Gather all the declared directories for list_new_commits, except for
        # '-'.
        [ "$d" = - ] || declared="$declared${declared:+ }$d"

        # Return early if there is no ref for this directory.
        if [ "$r" = - ]; then
            sha1dirs=( "${sha1dirs[@]}" "$rd" )
            continue
        fi

        if [ "${r:0:1}" = % ]; then
            # Handle repeat logic for this directory.
            [ -z "$repeat" ] || [ "$repeat" = "${r:1}" ] ||
                error "mismatched repeat in '$rd' (expected: '$repeat')"
            sha1dirs=( "${sha1dirs[@]}" "%:$d" )

            if [ "$d" = - ]; then
                repeated_root=1
            else
                repeated=( "${repeated[@]}" "$d/" )
            fi

            [ -z "$repeat" ] || continue
            repeat="${r:1}"
            suffix=mt-repeat r="$repeat" d=%
            rd="${r%\{no-pass\}}:$d"
            [ "$rd" = "$r:$d" ] || nopass=1
        else
            # Figure out the goal sha1 for this directory.  Note that the
            # repeat goal is determined below.
            goal_sha1=$(run --hide-errors git rev-parse --verify $r^{commit}) ||
                error "failed to extract goal sha1 from '$r' for dir '$d'"
            goal_sha1dirs=( "${goal_sha1dirs[@]}" "$goal_sha1:$d" )
        fi

        ref=refs/heads/mt/$branch/$suffix
        sha1=$(run --hide-errors git rev-parse --verify $ref^{commit}) ||
            sha1=$ZERO_SHA1

        sha1dirs=( "${sha1dirs[@]}" "$sha1:$d" )
        listdirs=( "${listdirs[@]}" "$rd" )
    done

    # Figure out the latest commit date coming in.
    local until ct
    if [ -n "$nopass" ]; then
        until=0
        for rd in "${refdirs[@]}"; do
            [ "${rd:0:1}" = % ] && continue
            [ "${rd:0:1}" = - ] && continue
            r="${rd%:*}"
            ct=$(run git log --format=%ct -1 "$r") ||
                error "failed to extract committer date from ref '$r'"
            [ $until -ge $ct ] || until=$ct
        done
    fi

    # Set a goal commit for the repeat.
    if [ -n "$repeat" ] && goal_sha1="$(list_first_new_repeat_commit \
        --skip-show-ref "$repeat" "%" "$branch" "$until")"
    then
        goal_sha1dirs=( "${goal_sha1dirs[@]}" "$goal_sha1:%" )
    fi

    list_new_commits "$branch" "${listdirs[*]}" "${repeated[*]}" $until |
    process_new_commits ||
        exit 1
}

process_new_commits() {
    # Build this here so that build_executable is cached for the pipeline.
    local split2mono
    split2mono="$(build_executable split2mono)" ||
        error "could not build split2mono"

    local head new_sha1dirs
    interleave_commits "$branch" "${sha1dirs[*]}" "${goal_sha1dirs[*]}" ||
        exit 1
    update_refs "$branch" "$current" "${sha1dirs[*]}" || exit 1
}

list_new_commits() {
    local branch="$1"
    local refdirs="$2"
    local repeated="$3"
    local until=$4
    local rd r d head tail format tailref headref suffix extra nots
    local add_repeated_root extra_repeated
    local -a new_commits_git_args
    for rd in $refdirs; do
        r="${rd%:*}"
        d="${rd##*:}"

        new_commits_git_args=()
        construct_list_new_commits_git_args "$r" "$d" "$branch" "$until" ||
            continue
        mt_list_commits "$d" "${new_commits_git_args[@]}" ||
            error "failed to list new commits for $rd"
    done
}

list_first_new_repeat_commit() {
    local -a new_commits_git_args
    construct_list_new_commits_git_args "$@" || return 1
    [ "${#new_commits_git_args[@]}" -ne 0 ] || return 1
    git rev-list -1 "${new_commits_git_args[@]}"
}

construct_list_new_commits_git_args() {
    # From parent: local -a new_commits_args
    local skip_show_ref
    if [ "$1" = "--skip-show-ref" ]; then
        skip_show_ref=1
        shift
    fi
    local extra= nots=
    local r="$1" d="$2" branch="$3" until="$4"
    local add_repeated_root= extra_repeated=
    local tailref headref head tail suffix
    if [ "$d" = % ]; then
        run --hide-errors git rev-parse --verify $branch^{commit} \
            >/dev/null &&
            nots=$branch
        suffix=mt-repeat
        extra="--first-parent${until:+ --until=}$until --"
        extra="$extra${repeated:+ }$repeated"
        add_repeated_root=$repeated_root
    else
        suffix="$d/mt-split"
    fi
    tailref="refs/heads/mt/$branch/$suffix"
    headref="$r"
    tail="$(run --hide-errors git rev-parse --verify $tailref^{commit})"
    head="$(run --hide-errors git rev-parse --verify $headref^{commit})" ||
        error "invalid ref '$headref' from '$rd'"
    [ "$tail" = "$head" ] && return 1

    # TODO: add a testcase for d of '-', which requires '--' here.
    if [ -z "$skip_show_ref" ]; then
        nots="$nots${nots:+ }$(run git show-ref -- $suffix |
            grep refs/heads/mt/ | awk '{print $2}')"
    fi

    if [ -n "$add_repeated_root" ]; then
        # List all the top-level paths touched in the root, so we can
        # select those commits to repeat.  We don't have to keep "repeated"
        # paths here since they're already attached to extra.
        extra_repeated="$(mt_list_modified_top_level_paths "$tail" "$head" \
            "-" "$declared")"
        extra="$extra${extra_repeated:+ }$extra_repeated"
    fi

    new_commits_git_args=( $headref --not $nots $extra )
}

interleave_commits() {
    # From parent: local head new_sha1dirs
    local branch="$1"
    local sha1dirs="$2"
    local goal_sha1dirs="$3"

    ref=refs/heads/${branch#refs/heads/}
    head=$(run --hide-errors git rev-parse --verify $ref^{commit}) ||
        head=$ZERO_SHA1
    local result
    result="$(run "$split2mono" interleave-commits \
        "$MT_DB_SPLIT2MONO_DB" "$MT_DB_SVN2GIT_DB" \
        "$head" $sha1dirs -- $goal_sha1dirs)" ||
        error "failure interleaving commits"
    head="${result%% *}"
    new_sha1dirs="${result#* }"
    [ "${VERBOSE:-0}" = 0 ] || log "translation: $head $new_sha1dirs"
}

update_refs() {
    # From parent: local head new_sha1dirs
    local branch="${1#refs/heads/}"
    local current="$2"
    local old_sha1dirs="$3"

    # Detect failure.  No reason to report a new error.
    [ -n "$head" ] || return 1

    local ref=refs/heads/$branch
    {
        log "Updating $branch => $head"
        run printf "update %s %s %s\n" $ref $head $current
        local old_sha1 new_sha1 new_sd sd d
        for sd in $old_sha1dirs; do
            d=${sd#*:}
            old_sha1=${sd%:*}
            new_sha1=
            case "$old_sha1" in
                -|%) continue ;;
                *)   true ;;
            esac
            if [ "$d" = % ]; then
                ref=refs/heads/mt/$branch/mt-repeat
            else
                ref=refs/heads/mt/$branch/$d/mt-split
            fi
            for new_sd in $new_sha1dirs; do
                [ "$d" = "${new_sd#*:}" ] || continue
                new_sha1=${new_sd%:*}
                break
            done
            if [ -z "$new_sha1" ]; then
                printf "poison update-ref\n"
                error "missing output sha1 for '$d'"
            fi
            if [ $new_sha1 = $ZERO_SHA1 -a \
                ! "$new_sha1" = "$old_sha1" ]; then
                printf "poison update-ref\n"
                error "internal: new value for $ref is $new_sha1" \
                    "but it was $old_sha1"
            fi
            if [ "$new_sha1" = "$old_sha1" ]; then
                log " - ${ref#refs/heads/} == $new_sha1"
                run printf "verify %s %s\n" $ref $new_sha1
            else
                log " - ${ref#refs/heads/} => $new_sha1"
                run printf "update %s %s %s\n" $ref $new_sha1 $old_sha1
            fi
        done
    } | run git update-ref --stdin ||
        error "failed to update $branch and $refdirs"
}

main "$@"
